/*
 * Copyright(c) 2020-2024 All rights reserved by Heekuck Oh.
 * 이 프로그램은 한양대학교 ERICA 컴퓨터학부 학생을 위한 교육용으로 제작되었다.
 * 한양대학교 ERICA 학생이 아닌 자는 이 프로그램을 수정하거나 배포할 수 없다.
 * 프로그램을 수정할 경우 날짜, 학과, 학번, 이름, 수정 내용을 기록한다.
 * 날짜 : 20240916 / 학과 : 컴퓨터학부 / 학번 : 2022001149 / 이름 : 우상민 
 * 수정 내용 : 
 *   - 20240916 : 없음
 *   - 20240927 : AES-192,256 검증용 벡터값 추가, AES-192,256 검증 로직 추가
 */
#include <stdio.h>
#include <string.h>
#include <time.h>
#ifdef __linux__
#include <bsd/stdlib.h>
#elif __APPLE__
#include <stdlib.h>
#else
#include <stdlib.h>
#endif
#include "aes.h"
#include <endian.h>

/*
 *  ================= 128 비트 AES 검증 데이터 =================
 *  <키>: 0f 15 71 c9 47 d9 e8 59 0c b7 ad d6 af 7f 67 98
 *  <라운드 키>:
 *  0f 15 71 c9 47 d9 e8 59 0c b7 ad d6 af 7f 67 98
 *  dc 90 37 b0 9b 49 df e9 97 fe 72 3f 38 81 15 a7
 *  d2 c9 6b b7 49 80 b4 5e de 7e c6 61 e6 ff d3 c6
 *  c0 af df 39 89 2f 6b 67 57 51 ad 06 b1 ae 7e c0
 *  2c 5c 65 f1 a5 73 0e 96 f2 22 a3 90 43 8c dd 50
 *  58 9d 36 eb fd ee 38 7d 0f cc 9b ed 4c 40 46 bd
 *  71 c7 4c c2 8c 29 74 bf 83 e5 ef 52 cf a5 a9 ef
 *  37 14 93 48 bb 3d e7 f7 38 d8 08 a5 f7 7d a1 4a
 *  48 26 45 20 f3 1b a2 d7 cb c3 aa 72 3c be 0b 38
 *  fd 0d 42 cb 0e 16 e0 1c c5 d5 4a 6e f9 6b 41 56
 *  b4 8e f3 52 ba 98 13 4e 7f 4d 59 20 86 26 18 76
 *  <평문>: 01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10
 *  <암호문>: ff 0b 84 4a 08 53 bf 7c 69 34 ab 43 64 14 8f b9
 */

/*
 * 128 비트 AES 검증용 벡터값
 */
// uint8_t key[KEYLEN] = {0x0f,0x15,0x71,0xc9,0x47,0xd9,0xe8,0x59,0x0c,0xb7,0xad,0xd6,0xaf,0x7f,0x67,0x98};
// uint32_t rkey[RNDKEYLEN] = {0xc971150f,0x59e8d947,0xd6adb70c,0x98677faf,0xb03790dc,0xe9df499b,0x3f72fe97,0xa7158138,0xb76bc9d2,0x5eb48049,0x61c67ede,0xc6d3ffe6,0x39dfafc0,0x676b2f89,0x6ad5157,0xc07eaeb1,0xf1655c2c,0x960e73a5,0x90a322f2,0x50dd8c43,0xeb369d58,0x7d38eefd,0xed9bcc0f,0xbd46404c,0xc24cc771,0xbf74298c,0x52efe583,0xefa9a5cf,0x48931437,0xf7e73dbb,0xa508d838,0x4aa17df7,0x20452648,0xd7a21bf3,0x72aac3cb,0x380bbe3c,0xcb420dfd,0x1ce0160e,0x6e4ad5c5,0x56416bf9,0x52f38eb4,0x4e1398ba,0x20594d7f,0x76182686};
// uint8_t ptxt[BLOCKLEN] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
// uint8_t ctxt[BLOCKLEN] = {0xff,0x0b,0x84,0x4a,0x08,0x53,0xbf,0x7c,0x69,0x34,0xab,0x43,0x64,0x14,0x8f,0xb9};

/*
 * 192 비트 AES 검증용 벡터값
 */
// uint8_t key[KEYLEN] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};
// uint32_t rkey[RNDKEYLEN] = {0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0xf9f24658, 0xfef4435c, 0xf5fe4a54, 0xfaf04758, 0xe9e25648, 0xfef4435c, 0xb349f940, 0x4dbdba1c, 0xb843f048, 0x42b3b710, 0xab51e158, 0x55a5a204, 0x41b5ff7e, 0x0c084562, 0xb44bb52a, 0xf6f8023a, 0x5da9e362, 0x080c4166, 0x728501f5, 0x7e8d4497, 0xcac6f1bd, 0x3c3ef387, 0x619710e5, 0x699b5183, 0x9e7c1534, 0xe0f151a3, 0x2a37a01e, 0x16095399, 0x779e437c, 0x1e0502ff, 0x880e7edd, 0x68ff2f7e, 0x42c88f60, 0x54c1dcf9, 0x235f9f85, 0x3d5a8d7a, 0x5229c0c0, 0x3ad6efbe, 0x781e60de, 0x2cdfbc27, 0x8023a2a2, 0x32daae0f, 0x330a97a4, 0x09dc781a, 0x71c218c4, 0x5d1da4e3 };
// uint8_t ptxt[BLOCKLEN] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
// uint8_t ctxt[BLOCKLEN] = {0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0, 0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91};

/*
 * 256 비트 AES 검증용 벡터값
 */
// uint8_t key[KEYLEN] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
// uint8_t ptxt[BLOCKLEN] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
// uint32_t rkey[RNDKEYLEN] = {0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c, 0x9fc273a5, 0x98c476a1, 0x93ce7fa9, 0x9cc072a5, 0xcda85116, 0xdabe4402, 0xc1a45d1a, 0xdeba4006, 0xf0df87ae, 0x681bf10f, 0xfbd58ea6, 0x6715fc03, 0x48f1e16d, 0x924fa56f, 0x53ebf875, 0x8d51b873, 0x7f8256c6, 0x1799a7c9, 0xec4c296f, 0x8b59d56c, 0x753ae23d, 0xe7754752, 0xb49ebf27, 0x39cf0754, 0x5f90dc0b, 0x48097bc2, 0xa44552ad, 0x2f1c87c1, 0x60a6f545, 0x87d3b217, 0x334d0d30, 0x0a820a64, 0x1cf7cf7c, 0x54feb4be, 0xf0bbe613, 0xdfa761d2, 0xfefa1af0, 0x7929a8e7, 0x4a64a5d7, 0x40e6afb3, 0x71fe4125, 0x2500f59b, 0xd5bb1388, 0x0a1c725a, 0x99665a4e, 0xe04ff2a9, 0xaa2b577e, 0xeacdf8cd, 0xcc79fc24, 0xe97909bf, 0x3cc21a37, 0x36de686d};
// uint8_t ctxt[BLOCKLEN] = {0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89};

uint8_t key[3][KEYLEN_256] = {
    {   0x0f, 0x15, 0x71, 0xc9, 0x47, 0xd9, 0xe8, 0x59,
        0x0c, 0xb7, 0xad, 0xd6, 0xaf, 0x7f, 0x67, 0x98 },
    {   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 },
    {   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }
};
uint8_t ptxt[3][BLOCKLEN] = {
    {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},
    {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff},
    {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff}
};
uint8_t ctxt[3][BLOCKLEN] = {
    {0xff, 0x0b, 0x84, 0x4a, 0x08, 0x53, 0xbf, 0x7c, 0x69, 0x34, 0xab, 0x43, 0x64, 0x14, 0x8f, 0xb9},
    {0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0, 0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91},
    {0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89}
};
uint32_t rkey[3][RNDKEYLEN_256] = {
    {0xc971150f,0x59e8d947,0xd6adb70c,0x98677faf, 0xb03790dc,0xe9df499b,0x3f72fe97,0xa7158138,
     0xb76bc9d2,0x5eb48049,0x61c67ede,0xc6d3ffe6, 0x39dfafc0,0x676b2f89,0x6ad5157,0xc07eaeb1,
     0xf1655c2c,0x960e73a5,0x90a322f2,0x50dd8c43, 0xeb369d58,0x7d38eefd,0xed9bcc0f,0xbd46404c,
     0xc24cc771,0xbf74298c,0x52efe583,0xefa9a5cf, 0x48931437,0xf7e73dbb,0xa508d838,0x4aa17df7,
     0x20452648,0xd7a21bf3,0x72aac3cb,0x380bbe3c, 0xcb420dfd,0x1ce0160e,0x6e4ad5c5,0x56416bf9,
     0x52f38eb4,0x4e1398ba,0x20594d7f,0x76182686 },

    {0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0xf9f24658, 0xfef4435c, 
     0xf5fe4a54, 0xfaf04758, 0xe9e25648, 0xfef4435c, 0xb349f940, 0x4dbdba1c, 0xb843f048, 0x42b3b710, 
     0xab51e158, 0x55a5a204, 0x41b5ff7e, 0x0c084562, 0xb44bb52a, 0xf6f8023a, 0x5da9e362, 0x080c4166, 
     0x728501f5, 0x7e8d4497, 0xcac6f1bd, 0x3c3ef387, 0x619710e5, 0x699b5183, 0x9e7c1534, 0xe0f151a3, 
     0x2a37a01e, 0x16095399, 0x779e437c, 0x1e0502ff, 0x880e7edd, 0x68ff2f7e, 0x42c88f60, 0x54c1dcf9, 
     0x235f9f85, 0x3d5a8d7a, 0x5229c0c0, 0x3ad6efbe, 0x781e60de, 0x2cdfbc27, 0x8023a2a2, 0x32daae0f, 
     0x330a97a4, 0x09dc781a, 0x71c218c4, 0x5d1da4e3 },

    {0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c, 
     0x9fc273a5, 0x98c476a1, 0x93ce7fa9, 0x9cc072a5, 0xcda85116, 0xdabe4402, 0xc1a45d1a, 0xdeba4006, 
     0xf0df87ae, 0x681bf10f, 0xfbd58ea6, 0x6715fc03, 0x48f1e16d, 0x924fa56f, 0x53ebf875, 0x8d51b873, 
     0x7f8256c6, 0x1799a7c9, 0xec4c296f, 0x8b59d56c, 0x753ae23d, 0xe7754752, 0xb49ebf27, 0x39cf0754, 
     0x5f90dc0b, 0x48097bc2, 0xa44552ad, 0x2f1c87c1, 0x60a6f545, 0x87d3b217, 0x334d0d30, 0x0a820a64, 
     0x1cf7cf7c, 0x54feb4be, 0xf0bbe613, 0xdfa761d2, 0xfefa1af0, 0x7929a8e7, 0x4a64a5d7, 0x40e6afb3, 
     0x71fe4125, 0x2500f59b, 0xd5bb1388, 0x0a1c725a, 0x99665a4e, 0xe04ff2a9, 0xaa2b577e, 0xeacdf8cd, 
     0xcc79fc24, 0xe97909bf, 0x3cc21a37, 0x36de686d}
};


int main(void)
{

    for (int k = 0 ; k < 3 ; k++) {
        uint32_t roundKey[RNDKEYLEN + 8*k];
        uint8_t *p, buf[BLOCKLEN];
        int i, count;
        clock_t start, end;
        double cpu_time;

        /*
        * 라운드 키 생성 시험
        */
        printf("<키>\n");
        for (i = 0; i < KEYLEN + 8*k; ++i)
            printf("%02x ", key[k][i]);
        printf("\n<라운드 키>\n");
        KeyExpansion(key[k], roundKey, k);
        for (i = 0; i < RNDKEYLEN + 8*k; ++i) {
            p = (uint8_t *)(roundKey+i);
            printf("%02x %02x %02x %02x ", p[0], p[1], p[2], p[3]);
            if ((i+1)%4 == 0)
                printf("\n");
        }
        if (memcmp(roundKey, rkey[k], (RNDKEYLEN + 8*k)*sizeof(uint16_t))) {
            printf(".....FAILED: 라운드 키 불일치\n");
            return 1;
        }
        /*
        * 암호문 생성 시험
        */
        printf("---\n<평문>\n");
        for (i = 0; i < BLOCKLEN; ++i)
            printf("%02x ", ptxt[k][i]);
        memcpy(buf, ptxt[k], BLOCKLEN);
        Cipher(buf, roundKey, ENCRYPT, k);
        printf("\n<암호문>\n");
        for (i = 0; i < BLOCKLEN; ++i)
            printf("%02x ", buf[i]);
        if (memcmp(buf, ctxt[k], BLOCKLEN)) {
            printf(".....FAILED: 암호문 불일치\n");
            return 1;
        }
        /*
        * 복호문 생성 시험
        */
        Cipher(buf, roundKey, DECRYPT, k);
        printf("\n<복호문>\n");
        for (i = 0; i < BLOCKLEN; ++i)
            printf("%02x ", buf[i]);
        if (memcmp(buf, ptxt[k], BLOCKLEN)) {
            printf(".....FAILED: 복호문 불일치\n");
            return 1;
        }
        /*
        * 역암호문 생성 및 복호화 시험
        */
        Cipher(buf, roundKey, DECRYPT, k);
        printf("\n<역암호문>\n");
        for (i = 0; i < BLOCKLEN; ++i)
            printf("%02x ", buf[i]);
        Cipher(buf, roundKey, ENCRYPT, k);
        printf("\n<복호문>\n");
        for (i = 0; i < BLOCKLEN; ++i)
            printf("%02x ", buf[i]);
        printf(".....PASSED\n");
        /*
        * 키와 평문을 무작위로 선택해서 암복호화를 여러번 수행하고 CUP 시간을 측정한다.
        */
        printf("---\nAES 성능시험"); fflush(stdout);
        start = clock();
        count = 0;
        do {
            arc4random_buf(key[k], KEYLEN + 8*k);
            KeyExpansion(key[k], roundKey, k);
            arc4random_buf(ptxt[k], BLOCKLEN);
            memcpy(buf, ptxt[k], BLOCKLEN);
            for (i = 0; i < 0x0ff; ++i)
                Cipher(buf, roundKey, ENCRYPT, k);
            for (i = 0; i < 0x1fe; ++i)
                Cipher(buf, roundKey, DECRYPT, k);
            for (i = 0; i < 0x0ff; ++i)
                Cipher(buf, roundKey, ENCRYPT, k);
            if (memcmp(buf, ptxt[k], BLOCKLEN)) {
                printf(".....FAILED: 복호문 불일치\n");
                return 1;
            }
            if (++count % 0xff == 0) {
                printf(".");
                fflush(stdout);
            }
        } while (count < 0xfff);
        end = clock();
        cpu_time = ((double)(end - start)) / CLOCKS_PER_SEC;
        printf(".....PASSED\nCPU 사용시간 = %.4f초\n", cpu_time);

    }

    return 0;
}
